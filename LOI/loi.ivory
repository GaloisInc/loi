-- # -*- mode: haskell -*-

include loiModule

-- LOI implementation in Ivory

g_STANAG_BROADCAST_ID = -1;
g_TAKE_CONTROL = 1;
g_RELINQUISH_HANDOFF_CONTROL = 0;
g_REQUEST_CONTROL = 1;
g_OVERRIDE_CONTROL = 2;

max_NUM_CUCS  = 6;
g_CUCS_OFFSET = 42;
g_TYPE_OFFSET = 14;
g_CUCS_AUTHORIZATION_REQUEST = 1;
g_PAYLOADSTEERINGCOMMAND = 200;
g_EOLASERPAYLOADCOMMAND = 201;
g_PAYLOADCONFIGURATION = 300;
g_EOIRCONFIGURATIONSTATE = 301;
g_EOIRLASEROPERATINGSTATE = 302;
g_FIELDCONFIGREQ = 1200;

uint8_t loi_2 = 0x01;
uint8_t loi_3 = 0x02;
uint8_t loi_4 = 0x04;
uint8_t loi_5 = 0x08;

--------------------------------------------------------------------------------
-- XXX Made up definitions for now

-- Startup config values
mVehicleType    = 0;
mVehicleSubType = 0;
mVehicleId = 0;

--------------------------------------------------------------------------------

int32_t findResponse(int32_t cucsID) {
  map ix {
    if ((&mActiveCucs)@ix -> V.cucsId == cucsID) {
	  return safeCast(ix);
    } else {}
  }
  return -1;
}


int32_t getActiveCUCSCount() 
{
  alloc *cnt = 0;
  map ix {
    if ((&mActiveCucs)@ix -> V.cucsId != 0) {
      store cnt as *cnt + 1;
    } else {}
  }
  return *cnt;
}


bool stanagChecksum(*StanagBuf buf, uint32_t len)
{
    let bound = len - 4;
	let tomatch = unpackUint32(buf, bound);
    alloc *check = 0;
 
    let ix_t 576 boundIx = toIx(twosCompCast(bound));
    upTo boundIx ix {
        let uint32_t data = safeCast(buf[ix]);
        store check as *check + data;
    }

    return (*check == tomatch);
}


void processIncoming(*StanagBuf buf, uint32_t size)
{
	-- checksum check
	if (!stanagChecksum(buf, size))
	{
        -- LOG.notice("LOI : message from CUCS 0x%08X failed checksum", cucsId);
		return;
	} else {}

	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);

	if (msgType == g_CUCS_AUTHORIZATION_REQUEST)
	{
		alloc msg;
		C.cucsAuthorisationRequest_unpack(buf, msg);
		handleStanagCucsAuthorisationRequest(msg);
		ackAuthorisationRequest(msg);
		return;
	} else {}

	if (applyLoiMessageFilter(cucsId, msgType))
	{
		let uint32_t z = 0;
		alloc *offset = z;

		-- covert switch statement
		if ((msgType == g_PAYLOADSTEERINGCOMMAND) || (msgType == g_EOIRLASEROPERATINGSTATE) || (msgType == g_EOLASERPAYLOADCOMMAND))
		{
			store offset as 4;
		} else { 

		if (msgType == g_EOIRCONFIGURATIONSTATE)
		{
			store offset as 8;
		} else {
		
		if (msgType == g_PAYLOADCONFIGURATION)
		{
			store offset as 12;
		} else {}}}

		-- station message, figure out where to deliver it and do so (if there is a station present)
		if (*offset > 0)
		{
			let stationbits = unpackUint32(buf, (g_CUCS_OFFSET + *offset));
			map ii 
			{	-- TODO: how to do bit manip and masking, this one gets pruned
				if ((((1 << safeCast(ii)) & stationbits) > 0) && ((&mStations)@ii->nextValid))
				{
					--mStations[ii].next->processIncoming(buf, size);
				} else {}
			}
		}
		-- otherwise, this goes to the vehicle for processing
		else
		{
			-- mVehicle.next->processIncoming(buf, size);
		}
	} else {}

}


bool applyLoiMessageFilter( int32_t cucsId, uint32_t msgType )
{
    let idx = findResponse( cucsId );

    if (idx >= 0)  -- valid response
	{
    	--  Check if the LOI granted to the CUCS overlaps the minimum LOI required by the message.
		let granted = (&mActiveCucs)@toIx(idx)->V.loiGranted;
		let required = requiredLOI(msgType);
		if ( (required & granted) > 0) {
			return true;
		} else {}

		-- all field config req apparently go through as well
		if ( msgType == g_FIELDCONFIGREQ ) { 
			return true;
		} else {}

	} else {}

	return false;
}

void ackAuthorisationRequest( * struct CucsAuthorisationRequest msg )
{
	alloc ack;
--	alloc buf;

	store ack.M.originalMessageTimeStamp as msg->C.timeStamp;
	store ack.M.originalMessageInstanceId as msg->C.messageInstance;
	store ack.M.originalMessageType as msg->C.messageType;
	store ack.M.cucsId as msg->C.cucsId;
--	store ack->M.timeStamp as now(); -- double timestamp
	store ack.M.vehicleId as mVehicleId;
	store ack.M.vsmId as mVehicleId;  -- TODO: readin/store vsm id

--	M.messageAcknowledgement_pack(ack, buf);
--	mPrev->processOutgoing(buf, messageAcknowledgementLength());
}

void sendAuthorisationResponse( * struct VsmAuthorisationResponse msg )
{
--	alloc buf;
--	store msg->V.timeStamp as now(); -- double timestamp
	store msg.V.vehicleId as mVehicleId;
	store msg.V.vsmId as mVehicleId;  -- TODO: readin/store vsm id

--	V.vsmAuthorisationResponse_pack(msg, buf);
--	mPrev->processOutgoing(buf, vsmAuthorisationResponseLength());
}

uint8_t requiredLOI(uint32_t messageType)
{
	map ix {
    	if ((&mLOIMap)@ix -> msg == messageType) {
			return (&mLOIMap)@ix -> req;
		} else {}
	}
	return 0;
}

void processOutgoing(*StanagBuf buf, uint32_t size)
{
	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);
	let required = requiredLOI(msgType);

	if ( cucsId == g_STANAG_BROADCAST_ID )
	{
		let checksum = unpackUint32(buf, size-4);

		-- Scan the list of authorized CUCSs.
		map ix
		{ 
			-- Check if the authorization for the target CUCS overlaps that required by the message.
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if ( ((&mActiveCucs)@ix->V.cucsId != 0) && ((required & granted) > 0) )
			{
				let newCucsID = (&mActiveCucs)@ix->V.cucsId;
				alloc *newchecksum = checksum;
				--for (int ii = 0; ii < 32; ii += 8)
				--{
				--	newchecksum -= (STANAG_BROADCAST_ID >> ii) & 0x0FF;  // remove old broadcast char
				--	newchecksum += (cucsID >> ii) & 0x0FF;   // add new cucsID char
				--}

				packInt32(newCucsID, buf, g_CUCS_OFFSET);
				packUint32(*newchecksum, buf, size - 4);

				-- Send the message to the CUCS.
				--mPrev->processOutgoing(buf, size);
 			}
			else {}
		}
	}
	else -- unique CUCS, find and check its authorization
	{
		map ix
		{
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if (((&mActiveCucs)@ix->V.cucsId == cucsId) && ((required & granted) > 0 ))
			{
				-- mPrev->processOutgoing(buf, size);
 			} else {}
		}
	}
}

uint8_t generateAuthorized(int32_t cucsId)
{
	-- everyone can get 2
	alloc *authorized = loi_2;

	-- check if cucs has or can get 3
	map ii
	{
		-- there is a valid station at ii AND ( no current CUCS or the current CUCS is us )
		if ((&mStations)@ii->nextValid  &&
				(((&mStations)@ii->authIdx < 0)  || ((&mActiveCucs)@(toIx((&mStations)@ii->authIdx))->V.cucsId == cucsId)))
		{
			store authorized as *authorized | loi_3;
		} else {}
	}

	-- check if vehicle has or can get 4/5
	if (((&mVehicle)->authIdx < 0) || ((&mActiveCucs)@(toIx((&mVehicle)->authIdx))->V.cucsId == cucsId))
	{
		store authorized as *authorized | loi_4 | loi_5;
	} else {}

	return *authorized;
}

void requestLOI3(* struct CucsAuthorisationRequest request, int32_t responseIndex, int32_t stationIndex)
{
}

void requestLOI45(* struct CucsAuthorisationRequest request, int32_t responseIndex, int32_t requestedLOI)
{
}

void dropLOI(* struct CucsAuthorisationRequest request, int32_t responseIdx)
{
}

void requestLOI(* struct CucsAuthorisationRequest request, int32_t responseIdx)
{
}

void handleStanagCucsAuthorisationRequest(* struct CucsAuthorisationRequest request)
{
	let cucsId = request->C.cucsId;
	if ((cucsId == 0) || (cucsId == g_STANAG_BROADCAST_ID)) {
		return;
	} else {}

	-- Check for a broadcast message
	if (g_STANAG_BROADCAST_ID == request->C.vehicleId)
	{
		alloc authResp;
		let responseIdx = findResponse(cucsId);

		if (responseIdx < 0)
		{
			store authResp.V.cucsId as cucsId;
			store authResp.V.vehicleType as mVehicleType;
			store authResp.V.vehicleSubtype as mVehicleSubType;
			store authResp.V.loiGranted as 0;
			store authResp.V.loiAuthorized as 0;
			store authResp.V.controlledStation as 0;
		}
		else
		{
--			memcpy mActiveCucs@responseIdx authResp;
		}

		store authResp.V.loiAuthorized as generateAuthorized(authResp->V.cucsId);

		if (authResp->V.loiAuthorized != 0)
		{
			-- If CUCS is authorized to some level, respond with authorized LOIs/stations.
			store authResp.V.loiGranted as 0;
			store authResp.V.controlledStationMode as g_TAKE_CONTROL;
			sendAuthorisationResponse( authResp );
			--LOG.notice("LOI: CUCS 0x%08X is authorized for 0x%X", authResp.getCucsId(), authResp.getLOI_Authorized());
		}
		else
		{
			--LOG.notice("LOI: CUCS 0x%08X is not authorized on any level", authResp.getCucsId());
		}
	}
	else -- Message was sent directly to this VSM.
	{
		-- only let custom CUCS use OVERRIDE, ULB specific behaviour
--		if (( g_OVERRIDE_CONTROL == request->C.controlledStationMode ) && ( (0x00800000 & request->C.cucsId) == 0 )) {
--				store request->C.controlledStationMode as g_REQUEST_CONTROL;
--		} else {}

		-- if CUCS isn't registered with us yet and they are requesting something, create an entry for them
		alloc *responseIdx = findResponse(cucsId);
		if ((*responseIdx < 0) && (request->C.requestedHandoverLoi != 0))
		{
			store responseIdx as findResponse(0); -- first blank spot
			if (*responseIdx < 0)
			{
				--LOG.notice("LOI: CUCS list is FULL, ignoring requests");
				--SetStatusAlert(PRIORITY_NOMINAL,SUBSYS_VSM_STATUS,STATUS_CLEARABLE,VSM_NOMINAL_CUCS_TABLE_FULL,VSM_NOMINAL_CUCS_TABLE_FULL_TEXT,10);
				return;
			} else {}

	        -- memset(mActiveCucs@responseIdx, 0, sizeof(StanagVsmAuthorizationResponse));
			let idx = toIx(*responseIdx);

			store (&mActiveCucs)@idx.V.cucsId as request->C.cucsId;
			store (&mActiveCucs)@idx.V.vehicleType as mVehicleType;
			store (&mActiveCucs)@idx.V.vehicleSubtype as mVehicleSubType;
			store (&mActiveCucs)@idx.V.loiGranted as 0;
			store (&mActiveCucs)@idx.V.loiAuthorized as 0;
			store (&mActiveCucs)@idx.V.controlledStation as 0;
			-- LOG.notice("LOI: CUCS 0x%08X added to authorized list", request->getCucsId());
		} else {}

		let idx = toIx(*responseIdx);
		store (&mActiveCucs)@idx.V.loiAuthorized as generateAuthorized((&mActiveCucs)@idx->V.cucsId);

		-- Resolve the authorization request.
		if (g_RELINQUISH_HANDOFF_CONTROL == request->C.controlledStationMode) {
			dropLOI(request, *responseIdx);
		} else {
			requestLOI(request, *responseIdx);
		}

		if ( request->C.requestedHandoverLoi > 0 )
		{
			-- If CUCS is authorized to some level, respond with authorized LOIs/stations.
			alloc authResp;
--			memcpy mActiveCucs@responseIdx authResp;
			store authResp.V.loiGranted as 0;
			sendAuthorisationResponse( authResp );
			--LOG.notice("LOI: CUCS 0x%08X is authorized to LOI 0x%X", authResp.getCucsId(), authResp.getLOI_Granted());
		} else {}
	}
}

