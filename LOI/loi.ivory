-- # -*- mode: haskell -*-

include loiModule

-- LOI implementation in Ivory

g_STANAG_BROADCAST_ID = -1;
max_NUM_CUCS  = 6;
g_CUCS_OFFSET = 42;
g_TYPE_OFFSET = 14;
g_CUCS_AUTHORIZATION_REQUEST = 1;
g_PAYLOADSTEERINGCOMMAND = 200;
g_EOLASERPAYLOADCOMMAND = 201;
g_PAYLOADCONFIGURATION = 300;
g_EOIRCONFIGURATIONSTATE = 301;
g_EOIRLASEROPERATINGSTATE = 302;
g_FIELDCONFIGREQ = 1200;

uint8_t loi_2 = 0x01;
uint8_t loi_3 = 0x02;
uint8_t loi_4 = 0x04;
uint8_t loi_5 = 0x08;

--------------------------------------------------------------------------------
-- XXX Made up definitions for now

-- Startup config values
mVehicleType    = 0;
mVehicleSubType = 0;

--------------------------------------------------------------------------------

int32_t findResponse(int32_t cucsID) {
  map ix {
    if ((&mActiveCucs)@ix -> V.cucsId == cucsID) {
	  return safeCast(ix);
    } else {}
  }
  return -1;
}


int32_t getActiveCUCSCount() 
{
  alloc *cnt = 0;
  map ix {
    if ((&mActiveCucs)@ix -> V.cucsId != 0) {
      store cnt as *cnt + 1;
    } else {}
  }
  return *cnt;
}


bool stanagChecksum(*StanagBuf buf, uint32_t len)
{
    let bound = len - 4;
	let tomatch = unpackUint32(buf, bound);
    alloc *check = 0;
 
    let ix_t 576 boundIx = toIx(twosCompCast(bound));
    upTo boundIx ix {
        let uint32_t data = safeCast(buf[ix]);
        store check as *check + data;
    }

    return (*check == tomatch);
}


void processIncoming(*StanagBuf buf, uint32_t size)
{
	-- checksum check
	if (!stanagChecksum(buf, size))
	{
        -- LOG.notice("LOI : message from CUCS 0x%08X failed checksum", cucsId);
		return;
	} else {}

	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);

	if (msgType == g_CUCS_AUTHORIZATION_REQUEST)
	{
		-- alloc *struct CucsAuthorisationRequest msg;
		-- cucsAuthorisationRequest_unpack(buf, msg);

		-- handleStanagCucsAuthorisationRequest(msg);
		-- AckAuthorisationRequest(msg);
		return;
	} else {}

	if (applyLoiMessageFilter(cucsId, msgType))
	{
		let int32_t z = 0;
		alloc *offset = z;

		-- covert switch statement
		if ((msgType == g_PAYLOADSTEERINGCOMMAND) || (msgType == g_EOIRLASEROPERATINGSTATE) || (msgType == g_EOLASERPAYLOADCOMMAND))
		{
			store offset as 4;
		} else { 

		if (msgType == g_EOIRCONFIGURATIONSTATE)
		{
			store offset as 8;
		} else {
		
		if (msgType == g_PAYLOADCONFIGURATION)
		{
			store offset as 12;
		} else {}}}

		-- station message, figure out where to deliver it and do so (if there is a station present)
		if (*offset > 0)
		{
--			let stationbits = unpackUint32(buf, g_CUCS_OFFSET + *offset);
--			for (int ii = 0; ii < 32; ii++)
--			{
--				if ((((1 << ii) & stationbits) > 0) && (mStations[ii].nextvalid))
--				{
--					mStations[ii].next->processIncoming(buf, size);
--				}
--			}
		}
		-- otherwise, this goes to the vehicle for processing
		else
		{
			-- mVehicle.next->processIncoming(buf, size);
		}
	} else {}

}


bool applyLoiMessageFilter( int32_t cucsId, uint32_t msgType )
{
    let idx = findResponse( cucsId );

    if (idx >= 0)  -- valid response
	{
    	--  Check if the LOI granted to the CUCS overlaps the minimum LOI required by the message.
		let granted = (&mActiveCucs)@toIx(idx)->V.loiGranted;
		let required = requiredLOI(msgType);
		if ( (required & granted) > 0) {
			return true;
		} else {}

		-- all field config req apparently go through as well
		if ( msgType == g_FIELDCONFIGREQ ) { 
			return true;
		} else {}

	} else {}

	return false;
}

void ackAuthorisationRequest( * struct CucsAuthorisationRequest msg )
{
}

void sendAuthorisationResponse( * struct VsmAuthorisationResponse msg )
{
}

uint8_t requiredLOI(uint32_t messageType)
{
	map ix {
    	if ((&mLOIMap)@ix -> msg == messageType) {
			return (&mLOIMap)@ix -> req;
		} else {}
	}
	return 0;
}

void processOutgoing(*StanagBuf buf, uint32_t size)
{
	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);
	let required = requiredLOI(msgType);

	if ( cucsId == g_STANAG_BROADCAST_ID )
	{
		let checksum = unpackUint32(buf, size-4);

		-- Scan the list of authorized CUCSs.
		map ix
		{ 
			-- Check if the authorization for the target CUCS overlaps that required by the message.
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if ( ((&mActiveCucs)@ix->V.cucsId != 0) && ((required & granted) > 0) )
			{
				let newCucsID = (&mActiveCucs)@ix->V.cucsId;
				alloc *newchecksum = checksum;
				--for (int ii = 0; ii < 32; ii += 8)
				--{
				--	newchecksum -= (STANAG_BROADCAST_ID >> ii) & 0x0FF;  // remove old broadcast char
				--	newchecksum += (cucsID >> ii) & 0x0FF;   // add new cucsID char
				--}

				packInt32(newCucsID, buf, g_CUCS_OFFSET);
				packUint32(*newchecksum, buf, size - 4);

				-- Send the message to the CUCS.
				--mPrev->processOutgoing(buf, size);
 			}
			else {}
		}
	}
	else -- unique CUCS, find and check its authorization
	{
		map ix
		{
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if (((&mActiveCucs)@ix->V.cucsId == cucsId) && ((required & granted) > 0 ))
			{
				-- mPrev->processOutgoing(buf, size);
 			} else {}
		}
	}
}

uint8_t generateAuthorized(int32_t cucsId)
{
	-- everyone can get 2
	alloc *authorized = loi_2;

	-- check if cucs has or can get 3
	map ii
	{
		-- there is a valid station at ii AND ( no current CUCS or the current CUCS is us )
		if ((&mStations)@ii->nextValid  &&
				(((&mStations)@ii->authIdx < 0)  || ((&mActiveCucs)@(toIx((&mStations)@ii->authIdx))->V.cucsId == cucsId)))
		{
			store authorized as *authorized | loi_3;
		} else {}
	}

	-- check if vehicle has or can get 4/5
	if (((&mVehicle)->authIdx < 0) || ((&mActiveCucs)@(toIx((&mVehicle)->authIdx))->V.cucsId == cucsId))
	{
		store authorized as *authorized | loi_4 | loi_5;
	} else {}

	return *authorized;
}

void requestLOI3(* struct CucsAuthorisationRequest request, int32_t responseIndex, int32_t stationIndex)
{
}

void requestLOI45(* struct CucsAuthorisationRequest request, int32_t responseIndex, int32_t requestedLOI)
{
}

void dropLOI(* struct CucsAuthorisationRequest request, int32_t responseIdx)
{
}

void requestLOI(* struct CucsAuthorisationRequest request, int32_t responseIdx)
{
}

void handleStanagCucsAuthorisationRequest(* struct CucsAuthorisationRequest request)
{
}

