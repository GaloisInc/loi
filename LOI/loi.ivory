-- # -*- mode: haskell -*-

include loiModule
include loiMapModule
include C.stanagcucsauthorisationrequest
include V.stanagvsmauthorisationresponse
include M.stanagmessageacknowledgement

-- LOI implementation in Ivory

g_STANAG_BROADCAST_ID = -1;
g_RELINQUISH_CONTROL = 0;
g_TAKE_CONTROL = 1;
g_RELINQUISH_HANDOFF_CONTROL = 0;
g_REQUEST_CONTROL = 1;
g_OVERRIDE_CONTROL = 2;

g_CUCS_OFFSET = 42;
g_TYPE_OFFSET = 14;
g_CUCS_AUTHORIZATION_REQUEST = 1;
g_PAYLOADSTEERINGCOMMAND = 200;
g_EOLASERPAYLOADCOMMAND = 201;
g_PAYLOADCONFIGURATION = 300;
g_EOIRCONFIGURATIONSTATE = 301;
g_EOIRLASEROPERATINGSTATE = 302;
g_FIELDCONFIGREQ = 1200;

loi_2 = 0x01;
loi_3 = 0x02;
loi_4 = 0x04;
loi_5 = 0x08;

int32_t findResponse(int32_t cucsID) {
  map ix {
	if ((&mActiveCucs)@ix -> V.cucsId == cucsID) {
	  return safeCast(ix);
	} else {}
  }
  return -1;
}


int32_t getActiveCUCSCount() 
{
  alloc *cnt = 0;
  map ix {
	if ((&mActiveCucs)@ix -> V.cucsId != 0) {
	  store cnt as *cnt + 1;
	} else {}
  }
  return *cnt;
}


bool stanagChecksum(*StanagBuf buf, uint32_t len)
{
	let bound = len - 4;
	let tomatch = unpackUint32(buf, bound);
	alloc *check = 0;
 
	let ix_t 576 boundIx = toIx(twosCompCast(bound));
	upTo boundIx ix {
		let uint32_t data = safeCast(buf[ix]);
		store check as *check + data;
	}

	return (*check == tomatch);
}

void loiInit(uint16_t vt, uint16_t vst, int32_t vi)
{
	store (&mLOIConfig).vehicleType as vt;
	store (&mLOIConfig).vehicleSubType as vst;
	store (&mLOIConfig).vehicleId as vi;
}

void processIncoming(*StanagBuf buf, uint32_t size)
{
	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);

	-- checksum check
	if (!stanagChecksum(buf, size))
	{
		loggeri(1, "LOI : message from CUCS 0x%08X failed checksum", cucsId);
		return;
	} else {}

	if (msgType == g_CUCS_AUTHORIZATION_REQUEST)
	{
		alloc msg;
		C.cucsAuthorisationRequest_unpack(buf, msg);
		handleStanagCucsAuthorisationRequest(msg);
		ackAuthorisationRequest(msg);
		return;
	} else {}

	if (applyLoiMessageFilter(cucsId, msgType))
	{
		let uint32_t z = 0;
		alloc *offset = z;

		-- covert switch statement
		if ((msgType == g_PAYLOADSTEERINGCOMMAND) || (msgType == g_EOIRLASEROPERATINGSTATE) || (msgType == g_EOLASERPAYLOADCOMMAND))
		{
			store offset as 4;
		} else { 

		if (msgType == g_EOIRCONFIGURATIONSTATE)
		{
			store offset as 8;
		} else {
		
		if (msgType == g_PAYLOADCONFIGURATION)
		{
			store offset as 12;
		} else {}}}

		-- station message, figure out where to deliver it and do so (if there is a station present)
		if (*offset > 0)
		{
			let stationbits = unpackUint32(buf, (g_CUCS_OFFSET + *offset));
			map ii 
			{
				if ((((1 << safeCast(ii)) & stationbits) > 0) && ((&mStations)@ii->nextValid))
				{
					sendToStation(safeCast(ii), buf, size);
				} else {}
			}
		}
		-- otherwise, this goes to the vehicle for processing
		else
		{
			sendToVehicle(buf, size);
		}
	} else {}

}


bool applyLoiMessageFilter( int32_t cucsId, uint32_t msgType )
{
	let idx = findResponse( cucsId );

	if (idx >= 0)  -- valid response
	{
		--  Check if the LOI granted to the CUCS overlaps the minimum LOI required by the message.
		let granted = (&mActiveCucs)@toIx(idx)->V.loiGranted;
		let required = requiredLOI(msgType);
		if ( (required & granted) > 0) {
			return true;
		} else {}

		-- all field config req apparently go through as well
		if ( msgType == g_FIELDCONFIGREQ ) { 
			return true;
		} else {}

	} else {}

	return false;
}

void ackAuthorisationRequest( * struct CucsAuthorisationRequest msg )
{
	alloc ack;
--	alloc buf;

	store ack.M.originalMessageTimeStamp as msg->C.timeStamp;
	store ack.M.originalMessageInstanceId as msg->C.messageInstance;
	store ack.M.originalMessageType as msg->C.messageType;
	store ack.M.cucsId as msg->C.cucsId;
	store ack.M.timeStamp as timestamp(); -- double timestamp
	store ack.M.vehicleId as (&mLOIConfig)->vehicleId;
	store ack.M.vsmId as (&mLOIConfig)->vehicleId;  -- TODO: readin/store vsm id

--	M.messageAcknowledgement_pack(ack, buf);
--	sendToCucs(buf, M.messageAcknowledgementLength());
}

void sendAuthorisationResponse( * struct VsmAuthorisationResponse msg )
{
--	alloc buf;
	store msg.V.timeStamp as timestamp(); -- double timestamp
	store msg.V.vehicleId as (&mLOIConfig)->vehicleId;
	store msg.V.vsmId as (&mLOIConfig)->vehicleId;  -- TODO: readin/store vsm id

--	V.vsmAuthorisationResponse_pack(msg, buf);
--	sendToCucs(buf, V.vsmAuthorisationResponseLength());
}

uint8_t requiredLOI(uint32_t messageType)
{
	map ix {
		if ((&mLOIMap)@ix -> msg == messageType) {
			return (&mLOIMap)@ix -> req;
		} else {}
	}
	return 0;
}

void processOutgoing(*StanagBuf buf, uint32_t size)
{
	let cucsId = unpackInt32(buf, g_CUCS_OFFSET);
	let msgType = unpackUint32(buf, g_TYPE_OFFSET);
	let required = requiredLOI(msgType);

	if ( cucsId == g_STANAG_BROADCAST_ID )
	{
		let checksum = unpackUint32(buf, size-4);

		-- Scan the list of authorized CUCSs.
		map ix
		{ 
			-- Check if the authorization for the target CUCS overlaps that required by the message.
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if ( ((&mActiveCucs)@ix->V.cucsId != 0) && ((required & granted) > 0) )
			{
				let newCucsId = (&mActiveCucs)@ix->V.cucsId;
				alloc *newchecksum = checksum;
				let ix_t 5 top = 4;

				upTo top ii
				{
					let uint32_t byte = safeCast(ii)*8;
					let uint32_t mask = 0x0FF;
					store newchecksum as *newchecksum - ((twosCompRep(g_STANAG_BROADCAST_ID) >> byte) & mask); -- remove old broadcast char
					store newchecksum as *newchecksum + ((twosCompRep(newCucsId) >> byte) & mask);   -- add new cucsID char
				}

				packInt32(newCucsId, buf, g_CUCS_OFFSET);
				packUint32(*newchecksum, buf, size - 4);

				-- Send the message to the CUCS.
				sendToCucs(buf, size);
 			}
			else {}
		}
	}
	else -- unique CUCS, find and check its authorization
	{
		map ix
		{
			let granted = (&mActiveCucs)@ix->V.loiGranted;
			if (((&mActiveCucs)@ix->V.cucsId == cucsId) && ((required & granted) > 0 ))
			{
				sendToCucs(buf, size);
 			} else {}
		}
	}
}

uint8_t generateAuthorized(int32_t cucsId)
{
	-- everyone can get 2
	alloc *authorized = loi_2;

	-- check if cucs has or can get 3
	map ii
	{
		-- there is a valid station at ii AND ( no current CUCS or the current CUCS is us )
		if ((&mStations)@ii->nextValid  &&
				(((&mStations)@ii->authIdx < 0)  || ((&mActiveCucs)@(toIx((&mStations)@ii->authIdx))->V.cucsId == cucsId)))
		{
			store authorized as *authorized | loi_3;
		} else {}
	}

	-- check if vehicle has or can get 4/5
	if (((&mVehicle)->authIdx < 0) || ((&mActiveCucs)@(toIx((&mVehicle)->authIdx))->V.cucsId == cucsId))
	{
		store authorized as *authorized | loi_4 | loi_5;
	} else {}

	return *authorized;
}

void requestLOI3(* struct CucsAuthorisationRequest request, CucsIdx responseIndex, StationIdx stationIndex)
{
	alloc *update = false;
	let authIdxx = (&mStations)@stationIndex->authIdx;

	-- noone has control or we already have control
	if ((authIdxx < 0) || (request->C.cucsId == (&mActiveCucs)@toIx(authIdxx)->V.cucsId))
	{
		-- allows a new CUCS to obtain control or the controlling CUCS to change between override and request mode
		store (&mStations)@stationIndex.overriden as (request->C.controlledStationMode == g_OVERRIDE_CONTROL);
		if ( authIdxx < 0 ) {
			store update as true;
		} else {}
	}
	else
	{
		-- can we override another CUCS control?
		let resp = (&mActiveCucs)@toIx(authIdxx);

		if ((g_OVERRIDE_CONTROL == request->C.controlledStationMode) && !(&mStations)@stationIndex->overriden)
		{
			store (&mStations)@stationIndex.overriden as true;
			store update as true;

			-- Clear the station entry for this CUCS.
			store resp.V.controlledStation as ( safeCast(resp->V.controlledStation) & ~(1 << safeCast(stationIndex)));

			if ( resp->V.controlledStation == 0)
			{
				-- If this CUCS is no longer in control of any stations, revoke LOI 3.
				store resp.V.loiGranted as ( safeCast(resp->V.loiGranted) & ~loi_3 );
				loggeri(1, "LOI: CUCS 0x%08X controls no longer controls any stations", resp->V.cucsId);
			} else {}

			store resp.V.loiAuthorized as 0;
			store resp.V.controlledStationMode as g_RELINQUISH_CONTROL;

			-- Notify former CUCS it has lost control of this station.
			alloc authResp;
			memcpy authResp resp;
			store authResp.V.loiGranted as loi_3;
			store authResp.V.controlledStation as (1 << safeCast(stationIndex));
			store authResp.V.controlledStationMode as g_RELINQUISH_CONTROL;
			sendAuthorisationResponse( authResp );

			loggeriii(1, "LOI: CUCS 0x%08X snatched LOI 3 Station #%d from CUCS 0x%08X", (&mActiveCucs)@responseIndex->V.cucsId, safeCast(stationIndex)+1, resp->V.cucsId);
		} else {}
	}

	if (*update)
	{
		-- remember the CUCS in control of this station
		store (&mStations)@stationIndex.authIdx as safeCast(responseIndex);
		let resp = (&mActiveCucs)@responseIndex;
		store resp.V.loiGranted as ( resp->V.loiGranted | loi_3 );
		store resp.V.controlledStation as ( resp->V.controlledStation | (1 << safeCast(stationIndex)));

		loggerii(1, "LOI: CUCS 0x%08X controls Station #%d", resp->V.cucsId, safeCast(stationIndex)+1);
	} else {}
}


void requestLOI45(* struct CucsAuthorisationRequest request, CucsIdx responseIndex, uint8_t requestedLOI)
{
	let cur = (&mActiveCucs)@responseIndex;

	-- noone has control
	if ((&mVehicle)->authIdx < 0)
	{
		store (&mVehicle).authIdx as safeCast(responseIndex);
		store (&mVehicle).overriden as (g_OVERRIDE_CONTROL == request->C.controlledStationMode);
		store cur.V.loiGranted as cur->V.loiGranted | requestedLOI;
		return;
	}
	else {}

	-- we already have some control, possibly changing
	if ((&mVehicle)->authIdx == safeCast(responseIndex))
	{
		if (cur->V.loiGranted != requestedLOI) {
			store cur.V.loiGranted as safeCast(cur->V.loiGranted) & ~(loi_4|loi_5);
		} else {}
		loggerii(1, "LOI: CUCS 0x%08X changed LOI45, now at 0x%X", cur->V.cucsId, safeCast(requestedLOI));
		store (&mVehicle).overriden as (g_OVERRIDE_CONTROL == request->C.controlledStationMode);
		store cur.V.loiGranted as cur->V.loiGranted | requestedLOI;
		return;
	} else {}

	-- a cucs has control, can the requesting cucs override?
	if ((request->C.controlledStationMode == g_OVERRIDE_CONTROL) && !(&mVehicle)->overriden)
	{
		store (&mVehicle).overriden as true;

		-- Update the authorization table entry for the CUCS which was overridden.
		store cur.V.loiAuthorized as 0;
		store cur.V.loiGranted as (safeCast(cur->V.loiGranted) & ~requestedLOI);
		store cur.V.controlledStationMode as g_RELINQUISH_CONTROL;

		-- notify former CUCS in control of loss of LOI 4
		alloc authResp;
		memcpy authResp cur;
		store authResp.V.loiGranted as requestedLOI;
		store authResp.V.controlledStation as 0;
		store authResp.V.controlledStationMode as g_RELINQUISH_CONTROL;
		sendAuthorisationResponse( authResp );

		loggerii(1, "LOI: CUCS 0x%08X snatched LOI45 from CUCS 0x%08X", (&mActiveCucs)@responseIndex->V.cucsId, cur->V.cucsId);

		-- remember who has control of this AV
		store (&mVehicle).authIdx as safeCast(responseIndex);
		store (&mActiveCucs)@responseIndex.V.loiGranted as (&mActiveCucs)@responseIndex->V.loiGranted | requestedLOI;
	} else {}
}


void dropLOI(* struct CucsAuthorisationRequest request, CucsIdx responseIdx)
{
	let cur = (&mActiveCucs)@responseIdx;
	let prevgranted = cur->V.loiGranted;
	store cur.V.loiAuthorized as 0;

	--The Requested LOI is applicable to this request as it defines the functionality being released,
	--LOI 4/5 is for the air vehicle and LOI 3 is for the payload at the Controlled Station.
	--The CUCS inserts the Controlled Station Mode as Relinquish Control.

	loggerii(1, "LOI: CUCS 0x%08X attempting to relinquish LOI 0x%X", request->C.cucsId, safeCast(request->C.requestedHandoverLoi));

	if ((&mVehicle)->authIdx == safeCast(responseIdx)) -- compare as ints as we want to keep -1 if there
	{
		if (((safeCast(request->C.requestedHandoverLoi) & loi_5) > 0) && ((prevgranted & loi_5) > 0)) {
			store cur.V.loiGranted as safeCast(cur->V.loiGranted) & ~loi_5;
		} else {}

		if (((safeCast(request->C.requestedHandoverLoi) & loi_4) > 0) && ((prevgranted & loi_4) > 0)) {
			store cur.V.loiGranted as safeCast(cur->V.loiGranted) & ~loi_4;
		} else {}

		if ((safeCast(cur->V.loiGranted) & (loi_4|loi_5)) == 0)
		{
			store (&mVehicle).authIdx as -1;
			store (&mVehicle).overriden as false;
		} else {}
	} else {}

	if (((safeCast(request->C.requestedHandoverLoi) & loi_3) > 0) && ((prevgranted & loi_3) > 0))
	{
		let stations = request->C.controlledStation;
		map ii
		{	-- match this station bit and station is present and we are the controlling CUCS, note authIdx can be < 0
			if (((stations & (1 << safeCast(ii))) > 0) && (&mStations)@ii->nextValid && ((&mStations)@ii->authIdx == safeCast(responseIdx)))
			{
				store cur.V.controlledStation as safeCast(cur->V.controlledStation) & ~(1<<safeCast(ii));
				if ( cur->V.controlledStation == 0 ) {
					store cur.V.loiGranted as safeCast(cur->V.loiGranted) & ~loi_3;
				} else {}
				store (&mStations)@ii.authIdx as -1;
				store (&mStations)@ii.overriden as false;
				store cur.V.loiAuthorized as cur->V.loiAuthorized | loi_3;
			} else {}
		}
	} else {}

	if (((safeCast(request->C.requestedHandoverLoi) & loi_2) > 0) && ((prevgranted & loi_2) > 0))
	{
		store cur.V.loiGranted as safeCast(cur->V.loiGranted) & ~loi_2;
	} else {}

	if ( cur->V.loiGranted == 0 )
	{
		-- 'remove' the response from the list of active cucs
		loggeri(1, "LOI: CUCS 0x%08X removed from authorized list", cur->V.cucsId);
		store cur.V.cucsId as 0;
	} else {}

	-- Respond with the LOIs/stations relinquished.
	alloc authResp;
	memcpy authResp cur;
	store authResp.V.loiGranted as request->C.requestedHandoverLoi;
	if ((safeCast(request->C.requestedHandoverLoi) & loi_3) > 0) {
		store authResp.V.controlledStation as request->C.controlledStation;
	} else {
		store authResp.V.controlledStation as 0;
	}
	store authResp.V.controlledStationMode as g_RELINQUISH_CONTROL;
	sendAuthorisationResponse( authResp );

	if ( prevgranted != cur->V.loiGranted )
	{
		-- Indicate the LOIs relinquished as a result of this request.
		let relinquished = prevgranted & (prevgranted ^ cur->V.loiGranted);
		loggerii(1, "LOI: CUCS 0x%08X relinquished LOI 0x%X", cur->V.cucsId, safeCast(relinquished));
		loggerii(1, "LOI: CUCS 0x%08X has LOI 0x%X", cur->V.cucsId, safeCast(cur->V.loiGranted));
	} else {}
}

void requestLOI(* struct CucsAuthorisationRequest request, CucsIdx responseIdx)
{
	let cur = (&mActiveCucs)@responseIdx;
	let prevgranted = cur->V.loiGranted;
	store cur.V.loiAuthorized as 0;

	loggerii(1, "LOI: CUCS 0x%08X requesting LOI 0x%X", request->C.cucsId, safeCast(request->C.requestedHandoverLoi));

	-- determine if CUCS wants to monitor this VSM
	if (((safeCast(request->C.requestedHandoverLoi) & loi_2) > 0) && ((safeCast(prevgranted) & loi_2) == 0))
	{
		store cur.V.loiGranted as loi_2;
		loggeri(1, "LOI: CUCS 0x%08X granted LOI2", cur->V.cucsId);
	} else {}

	-- determine if CUCS wants any payload control
	if ((safeCast(request->C.requestedHandoverLoi) & loi_3) > 0)
	{
		let stations = request->C.controlledStation;
		map ii
		{	-- match this station bit and station is present
			if (((stations & (1 << safeCast(ii))) > 0) && (&mStations)@ii->nextValid)
			{
				requestLOI3(request, responseIdx, ii);
			} else {}  
		}
	} else {}

	-- determine if CUCS wants AV control
	if ((safeCast(request->C.requestedHandoverLoi) & loi_4) > 0)
	{
		requestLOI45(request, responseIdx, loi_4);
	} else {}

	-- determine if CUCS wants AV and recovery control
	if ((safeCast(request->C.requestedHandoverLoi) & loi_5) > 0)
	{
		requestLOI45(request, responseIdx, loi_5);
	} else {}

	-- Respond with the overall LOIs/stations granted.
	store cur.V.controlledStationMode as g_TAKE_CONTROL;
	sendAuthorisationResponse( cur );

	if ( prevgranted != cur->V.loiGranted )
	{
		-- Indicate the LOIs granted/authorized as a result of this request.
		let granted = safeCast(cur->V.loiGranted) & (cur->V.loiGranted ^ prevgranted);
		loggerii(1, "LOI: CUCS 0x%08X granted LOI 0x%X", cur->V.cucsId, safeCast(granted));
		loggerii(1, "LOI: CUCS 0x%08X has LOI 0x%X", cur->V.cucsId, safeCast(cur->V.loiGranted));
	} else {}
}

void handleStanagCucsAuthorisationRequest(* struct CucsAuthorisationRequest request)
{
	let cucsId = request->C.cucsId;
	if ((cucsId == 0) || (cucsId == g_STANAG_BROADCAST_ID)) {
		return;
	} else {}

	-- Check for a broadcast message
	if (g_STANAG_BROADCAST_ID == request->C.vehicleId)
	{
		alloc authResp;
		let responseIdx = findResponse(cucsId);

		if (responseIdx < 0)
		{
			store authResp.V.cucsId as cucsId;
			store authResp.V.vehicleType as (&mLOIConfig)->vehicleType;
			store authResp.V.vehicleSubtype as (&mLOIConfig)->vehicleSubType;
			store authResp.V.loiGranted as 0;
			store authResp.V.loiAuthorized as 0;
			store authResp.V.controlledStation as 0;
		}
		else
		{
			let cur = (&mActiveCucs)@toIx(responseIdx);
			memcpy authResp cur;
		}

		store authResp.V.loiAuthorized as generateAuthorized(authResp->V.cucsId);

		if (authResp->V.loiAuthorized != 0)
		{
			-- If CUCS is authorized to some level, respond with authorized LOIs/stations.
			store authResp.V.loiGranted as 0;
			store authResp.V.controlledStationMode as g_TAKE_CONTROL;
			sendAuthorisationResponse( authResp );
			loggerii(1, "LOI: CUCS 0x%08X is authorized for 0x%X", authResp->V.cucsId, safeCast(authResp->V.loiAuthorized));
		}
		else
		{
			loggeri(1, "LOI: CUCS 0x%08X is not authorized on any level", authResp->V.cucsId);
		}
	}
	else -- Message was sent directly to this VSM.
	{
		-- only let custom CUCS use OVERRIDE, ULB specific behaviour
		if (( g_OVERRIDE_CONTROL == request->C.controlledStationMode ) && ( (0x00800000 & twosCompRep(request->C.cucsId)) == 0 )) {
				store request.C.controlledStationMode as g_REQUEST_CONTROL;
		} else {}

		-- if CUCS isn't registered with us yet and they are requesting something, create an entry for them
		alloc *responseIdx = findResponse(cucsId);
		if ((*responseIdx < 0) && (request->C.requestedHandoverLoi != 0))
		{
			store responseIdx as findResponse(0); -- first blank spot
			if (*responseIdx < 0)
			{
				logger(1, "LOI: CUCS list is FULL, ignoring requests");
				--SetStatusAlert(PRIORITY_NOMINAL,SUBSYS_VSM_STATUS,STATUS_CLEARABLE,VSM_NOMINAL_CUCS_TABLE_FULL,VSM_NOMINAL_CUCS_TABLE_FULL_TEXT,10);
				return;
			} else {}

			let idx = toIx(*responseIdx);

			-- memset mActiveCucs@idx 0
			store (&mActiveCucs)@idx.V.cucsId as request->C.cucsId;
			store (&mActiveCucs)@idx.V.vehicleType as (&mLOIConfig)->vehicleType;
			store (&mActiveCucs)@idx.V.vehicleSubtype as (&mLOIConfig)->vehicleSubType;
			store (&mActiveCucs)@idx.V.loiGranted as 0;
			store (&mActiveCucs)@idx.V.loiAuthorized as 0;
			store (&mActiveCucs)@idx.V.controlledStation as 0;
			loggeri(1, "LOI: CUCS 0x%08X added to authorized list", request->C.cucsId);
		} else {}

		let idx = toIx(*responseIdx);
		store (&mActiveCucs)@idx.V.loiAuthorized as generateAuthorized((&mActiveCucs)@idx->V.cucsId);

		-- Resolve the authorization request.
		if (g_RELINQUISH_HANDOFF_CONTROL == request->C.controlledStationMode) {
			dropLOI(request, toIx(*responseIdx));
		} else {
			requestLOI(request, toIx(*responseIdx));
		}

		if ( request->C.requestedHandoverLoi > 0 )
		{
			-- bwilson, yes, this is a second response, why?
			-- If CUCS is authorized to some level, respond with authorized LOIs/stations.
			alloc authResp;
			let cur = (&mActiveCucs)@toIx(*responseIdx);
			memcpy authResp cur;
			store authResp.V.loiGranted as 0;
			sendAuthorisationResponse( authResp );
			loggerii(1, "LOI: CUCS 0x%08X is authorized to LOI 0x%X", authResp->V.cucsId, safeCast(authResp->V.loiGranted));
		} else {}
	}
}

